import random
import re
 
 
CARDS = {
    "Two": 2,
    "Three": 3,
    "Four": 4,
    "Five": 5,
    "Six": 6,
    "Seven": 7,
    "Eight": 8,
    "Nine": 9,
    "Ten": 10,
    "Jack": 11,
    "Queen": 12,
    "King": 13,
    "Ace": 14
}
 
FACES = [
    "Spades",
    "Clubs",
    "Diamonds",
    "Hearts"]

#deck = []
#discard = []
#hand = []
#letterName = list(CARDS.keys())
 
#fill draw_pile
#for f in FACES:
#   for i in letterName:
#        deck.append(f"{i} {f}")

#CREAT DECK FUNCTION
def createdeck(file):
    """Function to create the entire deck.
    
    Side effects:
        append cards from the file to the deck
    
    Returns:
        deck (str): returns a deck as a string with all of the cards from the file
    """
    deck = []
    file = "deck.txt"
    with open(file, 'r', encoding = 'utf-8') as f:
        for line in f:
            deck.append(line)
    return deck

        
#regex that match group suits and card values
#this should go in the deal_hand() method
#expr = r"(?P<cardValue>^\S*)\s(?P<suitValue>\S*)"
#for element in deck:
#    match = re.search(expr, element)
#    cardValue = match.group(0)
#    suitValue = match.group(1)
   
class GameState:
    """A class for representing the state of the game
    
    Attributes:
        deck (str) : a deck with all the cards as a string
            
    Methods:
        repr (self): returns the current top card as a string
        dealcard (path): deals a card to the hand until the count equals 0
        draw_card (hand): draws a card to the hand 
        Current_top_card (card_suit): shows the current top card
        roundWinner (player1): displays the winner of the current round
        roundWinner (player2): displays the winner of the current round
        restock (self): changes the value of a class attribute 
        game_winner (p1hand): displays the winner of the game
        game_winner (p2hand): displays the winner of the game
        isCardValid (card): returns true if the card is the top suit and false if it is not
    """ 
    def __init__(self, deck):
        """Constructs all the necessary attributes for the gamestate object

        Args:
            top_suit (str): the top suit
            high_card (str): the highest card
            trick (list): the discard pile
            stock (list): the draw pile
        
        Side effects:
            initializes the top_suit, high_card, trick, and stock variables
        """
        self.top_suit = ""
        self.high_card = ""
        self.top_card = (f"{self.high_card} {self.top_suit}")
        self.trick = []
        self.stock = []
        #for i in deck:
        #  self.stock.append(i)
        deck = createdeck()
        self.stock = [i for i in deck] #LIST COMPREHENSION
        
    def __repr__(self):
        """Return a formal representation of the gamestate object."""
        return (f"The current top card is: {self.top_card}")

    def dealCard(self):
        """Draws a card to the hand
        
        Side effects:
            append cards from the deck to the hand
            removes the drawn card from the draw pile

        Returns:
            Returns the hand which contains the cards which have been dealed
        """
        hand = []
        count = 4
        while count > 0:
            new_card = random.choice(self.stock)
            hand.append(new_card)
            self.stock.remove(new_card)
            count -= 1
        return hand
            
    def draw_card(self, hand):     
        """Draws a card to the hand 
        
        Args:
        hand (list): a list which contains all the cards that the player has
        
        Side effects:
            append cards from the deck to the hand if the new card is not the top suit
            removes the drawn card from the draw pile if the new card is not the top suit
            removes the drawn card from the hand if the new card is the top suit

        Returns:
            Returns the hand which contains new card that has been drawn
        """
        #suit = []
        new_card = random.choice(self.stock)
        valid = False
        while valid == False:
          #print(f"new card 1 {new_card}")
          if self.top_suit not in new_card:
            new_card = random.choice(self.stock)
            #print(f"new card 2 {new_card}")
            hand.append(new_card)
            self.stock.remove(new_card)
          else:
            hand.remove(new_card)
            valid = True
        print(f"you played {new_card}\n")
        return hand
   
    def Current_top_card(self, card_suit):
        """Shows the current top card
        
        Args:
        card_suit (str): a string which shows the suit of the current card

        Side effects:
            initializes the top_suit variable
            
        """
        self.top_suit = card_suit
    
    def roundWinner(self, player1, player2):
        """Displays the winner of the current round
        
        Args:
        player1 (str): the first player displayed as a string
        player2 (str): the second player displayed as a string

        Returns:
            Returns 0 if the winner is player1 and returns 1 if the winner is player2
        """ 
        cards = [player1, player2]
        winner = max (cards, key= lambda x: CARDS[x]) #Lambda
        if winner == player1:
            return 0
        else:
            return 1
       
        
    def restock(self):
        """Changes the value of a class attribute 

        Returns:
            Returns none
        """
        #append trick to stock
        return None
           
    def game_winner(p1hand, p2hand):
        """Displays the winner of the game
        
        Args:
        p1hand (str): a string which contains the cards in the player 1's hand
        p2hand (str): a string which contains the cards in the player 2's hand 

        Returns:
            Returns the winner of the game 
        """ 
        winner = ""
        winner = ("Player 1") if (p1hand == []) else winner = "Player 2"
        return winner
  
    def isCardValid(self, card):
        """Determines whether the card is the top suit
        
        Args:
        card (str): the current card

        Returns:
            Returns true if the card is the top suit and false if it is not
        """
        if card == self.top_suit:  
            return True
        else:
            return False
   
   
class Player:
    """A class for representing the player 
    
    Attributes:
        deck (str) : a deck with all the cards as a string
        player_name (str) : the player name represented as a string
    """ 
    def __init__(self, deck, player_name="no_name"):
        """Constructs all the necessary attributes for the player object

        Args:
            player_name (str): the player name 
            hand (list): a list which contains all the cards that the player has
            top_card (str): the top card
            chosenCard (str): the card that is chosen 
            suits (list): a list of suits of each card in current hand
            nums (list): a list of the face values of each card in current hand
            playablecards (list): a list of all the cards that are playable
            play_card (str): the card that is played represented as a string
            card_index (int): the index of the card which has a default value of 0 
            
        
        Side effects:
            initializes the player_name, hand, top_card, chosenCard, suits, nums, playablecards, play_card, and card_index variables
        """ 
        #init player name
        self.player_name = player_name
        self.stock = []
        self.hand = []
        self.top_card = ""
        self.chosenCard = ""
        self.suits = []
        self.nums = []
       
        for i in deck:
            self.stock.append(i)
       
        # self.starting_hand = []       
   
class Human(Player):
    """A class for representing the human player
            
    Methods:
        take_turn (self): engages in a full turn of the game
    """  
    def take_turn(self):
        """Engages in a full turn of the game

        Side effects:
            appends the value of the suit to suits
            appends the value of the  card to nums
            appends the card to playable cards if it is playable
            removes the played card from the hand if the played card is valid
        """ 
        #get gamestate
        #check player's hand for playable cards
        #if none, draw till playable card
        #else, let player play a card
        #call isCardValid and return error till player plays valid card
        #remove played card from hand
        #pass new attributes into a current_gamestate variable (current top card, current stock, current trick, current high card, current winner)
        #print player's hand
        #print(f"Top Suit: {gamestate.top_suit}\n") THIS NEEDS TO BE IN THE MAIN NOT IN THE PLAYER CLASS
        print(f"start turn hand: {self.hand}\n")
       
        #create match groups for future use
        #^DONE IN Player CLASS INIT
        #self.suits = []
        #self.nums = []
        
        expr = r"(?P<cardValue>^\S*)\s(?P<suitValue>\S*)"
        for element in self.hand:
            match = re.search(expr, element)
            cardValue = match.group("cardValue")
            suitValue = match.group("suitValue")
            self.suits.append(suitValue)
            self.nums.append(cardValue)
       
        #check for playable cards
        current_gamestate = GameState(self.stock)
        playableCards = []
        count = 0
        for item in self.suits:
            if item == current_gamestate.topSuit:
                playableCards.append(f"{self.nums[count]} {item}\n")
            count += 1
       
        if playableCards == []:
            print("you must draw until playable card appears\n")
            self.hand = current_gamestate.draw_card(self.hand)
            print(f"your new current hand: {self.hand}\n")
        else:
          #play card
          play_card = int(input("please enter the index of a card to play: \n"))
          self.card_suit = self.suits[play_card]
          self.card_num = self.nums[play_card]
          val = False
          while val == False:
            if current_gamestate.isCardValid(self.suits[play_card]):
                  self.hand.remove(self.hand[play_card])
                  val = True
            else:
                play_card = int(input("invalid entry, try another card: \n"))
               
class Computer(Player):
    """A class for representing the computer player
            
    Methods:
        take_turn (self): engages in a full turn of the game
    """  
    def take_turn(self):
        """Engages in a full turn of the game

        Side effects:
            appends the value of the suit to suits
            appends the value of the  card to nums
            appends the card to playable cards if it is playable
            removes the played card from the hand if the played card is valid
        """ 
        print(f"Top Suit: {self.topSuit}\n")
        print(f"start turn hand: {self.hand}\n")
       
        #create match groups for future use
        #^DONE IN Player CLASS INIT
        #self.suits = []
        #self.nums = []
        
        expr = r"(?P<cardValue>^\S*)\s(?P<suitValue>\S*)"
        for element in self.hand:
            match = re.search(expr, element)
            cardValue = match.group("cardValue")
            suitValue = match.group("suitValue")
            self.suits.append(suitValue)
            self.nums.append(cardValue)
           
        current_gamestate = GameState(self.stock)
        playableCards = []
        count = 0
        for item in self.suits:
            if item == current_gamestate.topSuit:
                playableCards.append(f"{self.nums[count]} {item}\n")
            count += 1
           
        if playableCards == []:
            self.hand = current_gamestate.draw_card(self.hand)
        else:
          #play card
          play_card = random.choice(playableCards)
 
if __name__ == "__main__":
    #stock = []
    #for i in deck:
    #   stock.append(i)
   
    player1_name = input("input first player's name: \n")
    player2_name = input("input first player's name: \n")
   
    player1 = Human(player1_name, stock)
    for card in player1.hand:
        stock.remove(card)
    player2 = Computer(player2_name, stock)
    for card2 in player2.hand:    
        stock.remove(card2)
   
    game = True
    player = 0
    while game:
       
        if player1.hand == [] or player2.hand == []:
            GameState.game_winner()
            game = False
               
        elif player == 0:
            player1.take_turn()
            player2.take_turn()
            #top_card = player1.top_card
            #player = 1 - player
        elif player == 1:
            player2.take_turn()
            player1.take_turn()
            #top_card = player2.top_card
            #player = 1 - player
     
       
        player = GameState.round_winner(player1.card_num, player2.card_num)
       

